<script>
	import geoViewport from '@mapbox/geo-viewport';
	import {setupResizeObserver} from '@svizzle/ui/src/actions/resizeObserver';

	import {onMount} from 'svelte';

	import {_bbox_WS_EN, _bbox_WSEN, _zoom} from 'app/stores/selection';
	import {clearHero} from 'app/stores/interaction';
	import {getLatLon as getCoords} from 'app/utils/dataUtils';

	import {
		FIT_PADDING,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_TILE_SIZE
	} from '../consts';

	import {latLngBoundsToArray} from './utils';

	export let accessToken = null;
	export let CustomLayers = null;
	export let items = [];
	export let styleURL;
	export let withScaleControl = true;
	export let withZoomControl = true;

	// /* props */

	let customLayers;
	let height = 0;
	let isInteractive = true; // has to be true initially
	let Leaflet;
	let map;
	let mapcontainer;
	let projectFn;
	let showMarkers = true;
	let width = 0;

	/* resize */

	const {
		_writable: _size,
		resizeObserver
	} = setupResizeObserver();

	/* bbox */

	$: viewport = geoViewport.viewport(
		$_bbox_WSEN,
		[width, height],
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_TILE_SIZE
	);

	/* custom layers */

	$: projectFn && customLayers && customLayers.$set({projectFn});
	$: customLayers && customLayers.$set({showMarkers});
	$: height && items && width && customLayers &&
		customLayers.$set({
			getCoords,
			height,
			items,
			width,
		});

	const addCustomLayers = () => {
		if (CustomLayers) {
			const target = map.getPanes().overlayPane;
			console.log('target', target);

			customLayers = new CustomLayers({
				target,
				props: {
					getCoords,
					height,
					items,
					map,
					projectFn,
					showMarkers,
					width,
				}
			});
		}
	};

	// /* controls */

	// const addAttributionControl = () => {
	// 	map.addControl(
	// 		new mapboxgl.AttributionControl({
	// 			compact: true
	// 		})
	// 	)
	// };

	// const addScaleControl = () => {
	// 	map.addControl(
	// 		new mapboxgl.ScaleControl({
	// 			maxWidth: 80,
	// 			unit: 'metric'
	// 		}),
	// 		'bottom-right'
	// 	);
	// };

	// const addZoomControl = () => {
	// 	map.addControl(
	// 		new mapboxgl.NavigationControl({
	// 			showCompass: false
	// 		}),
	// 		'bottom-left'
	// 	);
	// };

	// const addControls = () => {
	// 	addAttributionControl();

	// 	if (withScaleControl) {
	// 		addScaleControl();
	// 	}

	// 	if (withZoomControl) {
	// 		addZoomControl();
	// 	}
	// };

	/* bbox */

	// const fitToBbox = () => {
	// 	map.fitBounds($_bbox_WS_EN, {
	// 		linear: true,
	// 		padding: {
	// 			bottom: FIT_PADDING,
	// 			left: FIT_PADDING,
	// 			right: FIT_PADDING,
	// 			top: FIT_PADDING,
	// 		}
	// 	});
	// };

	// /* events */

	const updateBbox = () => {
		if (map) {
			const bounds = latLngBoundsToArray(map.getBounds());
			_bbox_WS_EN.set(bounds);
		}
	}

	const setProjection = () => {
		if (map) {
			const projector = ([lng, lat]) => {
				const latLng = Leaflet.latLng(lat, lng);
				const point = map.latLngToLayerPoint(latLng);

				return point;
			}

			projectFn = projector;
		}
	};
	const updateZoom = () => {
		if (map) {
			const zoom = map.getZoom();
			_zoom.set(zoom);
		}
	}

	const setMapEvents = () => {
		map.on('move', () => {
			console.log('move')
			updateBbox();
		});
		map.on('zoomstart', () => {
			showMarkers = false;
			console.log('zoomstart')
		});
		map.on('zoom', () => {
			console.log('zoom')
			updateZoom();
		});
		map.on('zoomend', () => {
			console.log('zoomend')
			showMarkers = true;
		});
		map.on('click', () => {
			clearHero();
		});
	}

	/* methods */

	// FIXME TBD: bind instead?
	const setGeometry = () => {
		if (!mapcontainer) {
			return
		}

		const elementGeometry = getComputedStyle(mapcontainer);
		width = parseFloat(elementGeometry.width);
		height = parseFloat(elementGeometry.height);
	};

	const createMap = () => {
		const {center: [lng, lat], zoom} = viewport;

		Leaflet.mapbox.accessToken = accessToken;

		map = Leaflet.mapbox.map(mapcontainer, null, {
			// map state
			center: Leaflet.latLng(lat, lng),
			zoom,

			// interaction
			zoomSnap: 0,
			// zoomDelta: 1
		})
		.addLayer(Leaflet.mapbox.styleLayer(styleURL));

		map.whenReady(() => {
			setProjection();
			setMapEvents();
			addCustomLayers();
			// fitToBbox();

			setGeometry(); // ipad FIXME: initial svg is 100x100
		});

		// controls

		// addControls();
	};

	/* lifecycle */

	const getLeaflet = async () => {
		// needed because importing `mapbox.js` statically attaches `L` to `window`
		// which isn't available in server-side rendering
		const mapboxjs = await import('mapbox.js');

		Leaflet = mapboxjs.default;
	};

	onMount(async () => {
		setGeometry();
		await getLeaflet();
	});

	// eslint-disable-next-line no-unused-expressions, no-sequences
	$: $_size, map?.invalidateSize();
	$: Leaflet && mapcontainer && createMap();
</script>

<svelte:head>
	<link
		href='/css/mapbox.css'
		rel='stylesheet'
		type='text/css'
	>
</svelte:head>

<svelte:window on:resize={setGeometry} />

<div class='MapboxJs'>
	<div
		bind:this={mapcontainer}
		class='mapcontainer'
		use:resizeObserver
	></div>
</div>

<style>
	.MapboxJs {
		height: 100%;
		position: relative;
		width: 100%;
	}

	.mapcontainer {
		height: 100%;
		width: 100%;
	}
</style>
