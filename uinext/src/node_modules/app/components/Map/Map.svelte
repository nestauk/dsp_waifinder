<script>
	import { beforeUpdate, onMount } from 'svelte';

	import * as _ from 'lamb';
	import mapboxgl from 'mapbox-gl';
	import bbox from '@turf/bbox';
	import geoViewport from '@mapbox/geo-viewport';

	import {
		FIT_PADDING,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_TILE_SIZE,
		KEY_TO_ENABLE_SCROLL,
		// KEY_TO_ENABLE_SCROLL_EVENTS
	} from './consts';
	import {toGeoPoints} from 'app/utils/geoUtils';

	const makeFloatsValues = _.mapValuesWith(parseFloat);
	const getElementGeometry = (elem, additionalProps = []) => makeFloatsValues(
		_.pickIn(getComputedStyle(elem), [
			"width",
			"height",
			...additionalProps
		])
	);

	// import Shield from './Shield.svelte';

	export let accessToken;
	export let styleURL;
	export let withScaleControl;
	export let withZoomControl;
	/* state */

	let map;
	let mapCreated;
	let mapcontainer;
	let layers;
	let width = 0;
	let height = 0;
	let zoom = MAPBOXGL_MIN_ZOOM;
	// export let isShieldActive = false;
	// export let shieldMessage = '';
	export let isPointerOverMap = false;
	export let keyToEnableScroll = KEY_TO_ENABLE_SCROLL;
	export let fingers = 0;

				// has to be true initially, setting it in the state for consistency
	export let isInteractive = true;

	$: boundingBox = bbox(toGeoPoints([
		{
			Longitude: -7.57216793459,
			Latitude: 49.959999905
		},
		{
			Longitude: 1.68153079591,
			Latitude: 58.6350001085
		}
	]));
	$: viewport = geoViewport.viewport(
		boundingBox,
		[width, height],
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_TILE_SIZE
	);

	/* lifecycle */

	beforeUpdate(() => {
		if (viewport && height > 0 && !mapCreated) {
			mapCreated = true;
			createMap();
		}
	})

	onMount(() => {
		setGeometry();
	});

	/* methods */

	const setGeometry = () => {
		if (!mapcontainer) return;
		// const elementGeometry = getElementGeometry(mapcontainer);
		const elementGeometry = getComputedStyle(mapcontainer);
		width = parseFloat(elementGeometry.width);
		height = parseFloat(elementGeometry.height);
	};

	const createMap = () => {
		const {center, zoom} = viewport;

		mapboxgl.accessToken = accessToken;

		map = new mapboxgl.Map({
			container: mapcontainer,
			center,
			zoom,
			style: styleURL,
			renderWorldCopies: false,

			// interactions
			scrollZoom: false,  // shielded
			touchZoomRotate: isInteractive,
			dragPan: isInteractive,
			dragRotate: false,
			// we don't render dots in perspective
			pitchWithRotate: false,

			// we add this later to have it compact
			attributionControl: false,

		})
		.on('load', () => {
			//addContainer();
			//updateContainerGeometry();
			setMapEvents();
			// fitBoundsToItems();
			// enableItemsEditing();

			// ipad FIXME: initial svg is 100x100
			setGeometry();
		});

		// input events

		map.touchZoomRotate.disableRotation();

		// controls

		addControls();
	};

	/* controls */

	const addControls = () => {
		addAttributionControl();

		if (withScaleControl) {
			addScaleControl();
		}

		if (withZoomControl) {
			addZoomControl();
		}
	};

	const addAttributionControl = () => {
		map.addControl(new mapboxgl.AttributionControl({
			compact: true
		}))
	};

	const addScaleControl = () => {
		map.addControl(
			new mapboxgl.ScaleControl({
				maxWidth: 80,
				unit: 'metric'
			}),
			'bottom-right'
		);
	};

	const addZoomControl = () => {
		map.addControl(
			new mapboxgl.NavigationControl({
				showCompass: false
			}),
			'bottom-left'
		);
	};

	/* zoom */

	const fitBoundsToItems = () => {
		map.fitBounds(boundingBox, {
			linear: true,
			padding: {
				top: FIT_PADDING,
				bottom: FIT_PADDING,
				left: FIT_PADDING,
				right: FIT_PADDING
			}
		});
	};

	/* shield */

	/*
	const showShield = msgType => {
		let shieldMessage = '';
		switch (msgType) {
			case 'scroll':
				shieldMessage = `${keyToEnableScroll}-scroll to zoom`;
				break;
			case 'pinch':
				shieldMessage = 'Use two fingers to drag and zoom';
				break;
			default:
				break;
		};
		isShieldActive = true;
	};
	const hideShield = () => {
		isShieldActive = false;
		shieldMessage = '';
	};
	*/

	/* events */

	const setMapEvents = () => {
		const zoomed = ({target: map}) => {
			zoom = map.getZoom();
		};

		map
		.on('zoom', zoomed)
		.on('zoomend', zoomed);

		/*
		if (Modernizr.touchevents) {
			setMapTouchEvents();
		}
		*/
	}

	// interactivity

	const enableInteractivity = event => {
		map.dragPan.enable();
		map.touchZoomRotate.enable();
		isInteractive = true;
	};
	const disableInteractivity = event => {
		map.dragPan.disable();
		map.touchZoomRotate.disable();
		isInteractive = false;
	};

	/* desktop */

	// pointer

	const setPointerEntered = () => {
		isPointerOverMap = true;
	};
	const setPointerExited = () => {
		isPointerOverMap = false;
	};

	// scrollZoom

	const enableScrollToZoom = event => {
		map && map.scrollZoom.enable();
	};
	const disableScrollToZoom = event => {
		map && map.scrollZoom.disable();
	};

	// key events

	const onkeydown = event => {
		if (isPointerOverMap && event.key === keyToEnableScroll) {
			enableScrollToZoom();
			// hideShield();
		}
	};
	const onkeyup = (event) => {
		if (isPointerOverMap && event.key === keyToEnableScroll) {
			disableScrollToZoom();
		}
	};

	// mouse events

	const onmouseenter = event => {
		setPointerEntered();
	};
	const onmouseleave = event => {
		setPointerExited();
		// hideShield();
		disableScrollToZoom();
	};
	const onwheel = event => {
		/*
		if (!event[KEY_TO_ENABLE_SCROLL_EVENTS]) {
			showShield('scroll');
		}
		*/
	};

	/* touch device: note that
	- @touchstart, mapTouchEvent.points is the list of fingers ON the map
	- @touchend, mapTouchEvent.points is the list of fingers we have REMOVED FROM the map
	*/
	const setMapTouchEvents = () => {
		map
		.on('touchstart', mapTouchEvent => {
			const currentFingers = mapTouchEvent.points.length;
			fingers = currentFingers;
		})
		.on('touchmove', mapTouchEvent => {
			if (fingers === 1) {
				// !isShieldActive && showShield('pinch');
				isInteractive && disableInteractivity();
			} else {
				// isShieldActive && hideShield();
				!isInteractive && enableInteractivity();
			}
		})
		.on('touchend', mapTouchEvent => {
			fingers = previousFingers;
			const removedFingers = mapTouchEvent.points.length;
			const currentFingers = previousFingers - removedFingers;

			if (currentFingers === 1) {
				disableInteractivity();
				// showShield('pinch');
			} else {
				enableInteractivity();
				// hideShield();
			}

			fingers = currentFingers;
		});
	}
</script>

<svelte:head>
	<link rel='stylesheet' type='text/css' href='/css/mapbox-gl.css'>
</svelte:head>

<svelte:window
	on:resize={setGeometry}
	on:keyup={onkeyup}
	on:keydown={onkeydown}
/>

<div bind:this={layers} class='layers'
	on:mouseenter={onmouseenter}
	on:mouseleave={onmouseleave}
	on:wheel={onwheel}
>
	<div bind:this={mapcontainer} class='mapcontainer'></div>

	<!--
	<Shield
		isActive='{isShieldActive}'
		message='{shieldMessage}'
		on:animationDone={hideShield}
	/>
	-->
</div>

<style>
	.layers {
		width: 100%;
		height: 100%;
		position: relative;
	}

	.mapcontainer {
		width: 100%;
		height: 100%;
	}

	/*
	When we shield touch-drag mapbox sets this to none
	preventing to scroll with 1-finger on Android and Windows.
	FIXME: modifying the map css is a HACK as it might change in the future,
	let's not rely on this. TODO file an question/issue on mapbox's github
	*/
	:global(.mapboxgl-canvas-container) {
		touch-action: auto !important;
	}
	/*
	svg {
		width: 100%;
		height: 100%;
		position: absolute !important;
	}
	*/
</style>
