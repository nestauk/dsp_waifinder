<script>
	import geoViewport from '@mapbox/geo-viewport';
	import bbox from '@turf/bbox';
	import mapboxgl from 'mapbox-gl';
	import {beforeUpdate, onMount} from 'svelte';

	import {toGeoPoints} from 'app/utils/geoUtils';
	import {toPx} from "app/utils/domUtils";

	import * as d3 from "vendor/d3";

	import {
		FIT_PADDING,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_TILE_SIZE
	} from './consts';

	export let accessToken;
	export let styleURL;
	export let withScaleControl;
	export let withZoomControl;

	export let items = [];
	export let getItemID;
	export let getLink;
	export let getLngLat;

	/* state */

	let fingers = 0;
	let isInteractive = true; // has to be true initially
	let map;
	let mapCreated;
	let mapcontainer;
	let marker;
	let height = 0;
	let width = 0;

	// let arc;
	let markersContainer;
	// let previousArc;
	let previousHeight = 0;
	let previousItems;


	// temporary point list to compute bounding box
	$: boundingBox = bbox(toGeoPoints([
		{
			Longitude: -7.57216793459,
			Latitude: 49.959999905
		},
		{
			Longitude: 1.68153079591,
			Latitude: 58.6350001085
		}
	]));
	$: viewport = geoViewport.viewport(
		boundingBox,
		[width, height],
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_TILE_SIZE
	);

	/* lifecycle */

	beforeUpdate(() => {
		if (viewport && height > 0 && !mapCreated) {
			mapCreated = true;
			createMap();
		}

		if (markersContainer) {
			if (width || height !== previousHeight) {
				updateContainerGeometry();
			}
			/*
			if (arc !== previousArc) {
				updateMarkersRadius();
			}
			*/
			if (items !== previousItems) {
				updateMarkers();
				projectMarkers();
			}
		}
		previousHeight = height;
		// previousArc = arc;
		previousItems = items;
	})

	onMount(() => {
		setGeometry();
	});

	/* methods */

	const setGeometry = () => {
		if (!mapcontainer) {
			return
		};

		const elementGeometry = getComputedStyle(mapcontainer);
		width = parseFloat(elementGeometry.width);
		height = parseFloat(elementGeometry.height);
	};

	const createMap = () => {
		const {center, zoom} = viewport;

		mapboxgl.accessToken = accessToken;

		map = new mapboxgl.Map({
			container: mapcontainer,
			center,
			zoom,
			style: styleURL,
			renderWorldCopies: false,

			// interactions
			scrollZoom: isInteractive,
			dragPan: isInteractive,
			dragRotate: false,
			pitchWithRotate: false, // don't render dots in perspective
			touchZoomRotate: isInteractive,
			attributionControl: false, // we add this later to have it compact
		})
		.on('load', () => {
			addContainer();
			updateContainerGeometry();
			updateMarkers();
			setMapEvents();
			fitBoundsToItems();
			enableItemsEditing();

			setGeometry(); // ipad FIXME: initial svg is 100x100
		});
		// input events

		map.touchZoomRotate.disableRotation();

		// controls

		addControls();
	};

	/* controls */

	const addControls = () => {
		addAttributionControl();

		if (withScaleControl) {
			addScaleControl();
		}

		if (withZoomControl) {
			addZoomControl();
		}
	};

	const addAttributionControl = () => {
		map.addControl(
			new mapboxgl.AttributionControl({
				compact: true
			})
		)
	};

	const addScaleControl = () => {
		map.addControl(
			new mapboxgl.ScaleControl({
				maxWidth: 80,
				unit: 'metric'
			}),
			'bottom-right'
		);
	};

	const addZoomControl = () => {
		map.addControl(
			new mapboxgl.NavigationControl({
				showCompass: false
			}),
			'bottom-left'
		);
	};

		/* zoom */

	const fitBoundsToItems = () => {
		map.fitBounds(boundingBox, {
			linear: true,
			padding: {
				bottom: FIT_PADDING,
				left: FIT_PADDING,
				right: FIT_PADDING,
				top: FIT_PADDING,
			}
		});
	};

	/* container */

	const addContainer = () => {
		markersContainer =
			d3.select(map.getCanvasContainer())
			.append("svg")
			.style("position", "absolute");
	};

	const updateContainerGeometry = () => {
		markersContainer
		.attr("width", toPx(width))
		.attr("height", toPx(height));
	};

	/* markers */

	const updateMarkers = () => {
		let markerLocal =
			markersContainer
			.selectAll(".marker")
			.data(items, getItemID);

		markerLocal.exit().remove();

		const markerEnter =
			markerLocal.enter()
			.append("g")
			.attr("class", "marker")
			.attr("fill-opacity", 0.75)
			.style("cursor", "pointer")
			.on("click", d => {
				setInfoPanel(d);
			})
			.append('circle')
			.attr('r', 2);

		marker = markerLocal.merge(markerEnter);
	};

	/*
	const updateMarkersRadius = () => {
		marker.selectAll(".sector").attr("d", arc);
	};
	*/

	const getMarkerPosition = d => map.project(getLngLat(d));

	const projectMarkers = () => {
		marker.attr("transform", d => {
			const {x, y} = getMarkerPosition(d);

			return `translate(${x},${y})`;
		});
	};

	/* tooltip */

	const enableItemsEditing = () => {
		// this.fire("enableItemsEditing");
	};

	/* events */

	const setMapEvents = () => {
		map
		.on("move", () => {
			projectMarkers();
		})
		.on("resize", () => {
			projectMarkers();
		})

		// temporarilly extracted out of Modernizr
		if (('ontouchstart' in window) || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch) {
			setMapTouchEvents();
		}

	}

	// interactivity

	const enableInteractivity = event => {
		map.dragPan.enable();
		map.touchZoomRotate.enable();
		map.scrollZoom.enable();
		isInteractive = true;
	};

	const disableInteractivity = event => {
		map.dragPan.disable();
		map.touchZoomRotate.disable();
		map.scrollZoom.disable();
		isInteractive = false;
	};

	/* desktop */
	// pointer

	const setPointerEntered = () => {
		isPointerOverMap = true;
	};
	const setPointerExited = () => {
		isPointerOverMap = false;
	};

	// mouse events

	const onmouseenter = event => {
		setPointerEntered();
	};
	const onmouseleave = event => {
		setPointerExited();
	};

	/* touch device: note that
	- @touchstart, mapTouchEvent.points is the list of fingers ON the map
	- @touchend, mapTouchEvent.points is the list of fingers we have REMOVED FROM the map
	*/
	const setMapTouchEvents = () => {
		map
		.on('touchstart', mapTouchEvent => {
			const currentFingers = mapTouchEvent.points.length;
			fingers = currentFingers;
		})
		.on('touchmove', () => {
			if (fingers === 1) {
				isInteractive && disableInteractivity();
			} else {
				!isInteractive && enableInteractivity();
			}
		})
		.on('touchend', mapTouchEvent => {
			fingers = previousFingers;
			const removedFingers = mapTouchEvent.points.length;
			const currentFingers = previousFingers - removedFingers;
			if (currentFingers === 1) {
				disableInteractivity();
			} else {
				enableInteractivity();
			}
			fingers = currentFingers;
		});
	}
</script>

<svelte:head>
	<link rel='stylesheet' type='text/css' href='/css/mapbox-gl.css'>
</svelte:head>

<svelte:window
	on:resize={setGeometry}
/>

<div class='layers'>
	<div
		bind:this={mapcontainer}
		class='mapcontainer'
	></div>
</div>

<style>
	.layers {
		width: 100%;
		height: 100%;
		position: relative;
	}

	.mapcontainer {
		width: 100%;
		height: 100%;
	}
</style>
