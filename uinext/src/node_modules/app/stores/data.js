import {
	getId,
	getLength,
	getKey,
	getValue,
	isNotNil,
	objectToKeyValueArray,
	sortValueDescKeyAsc,
} from '@svizzle/utils';
import isEqual from 'just-compare';
import * as _ from 'lamb';
import {derived} from 'svelte/store';

import {_dataset} from 'app/stores/dataset';
import {
	_bbox_WSEN,
	_orgSearchRegex,
	_orgTypesSelectionMode,
	_placesSearchRegex,
	_selectedOrgTypes,
} from 'app/stores/selection';
import {countOrgTypes, getTopics} from 'app/utils/dataUtils';
import {isRegexpNotEmpty} from 'app/utils/svizzle/utils';

/* filtered orgs */

const makeIsOrgWithinBbox = ([w, s, e, n]) =>
	({location: {lat, lon}}) =>
		lon >= w &&
		lat >= s &&
		lon <= e &&
		lat <= n;

export const _bboxOrgs = derived(
	[_bbox_WSEN, _dataset],
	([bbox_WSEN, {orgs}]) => _.filter(orgs, makeIsOrgWithinBbox(bbox_WSEN))
);

/* [1] FIXME using:

```
const isSelectedType = makeIsIncluded(selectedTypes);
```

fails to select `University of Oxford` (which is a funder & a university),
if we select 'University / RTO' only

NOTE that this would work:

```
isSelectedType = _.pipe([tapValue(), makeIsIncluded(selectedTypes)])
```
*/
const makeIsOrgOfTypes = (selectedTypes, selectionMode) =>
	({types}) => {
		let passed;

		if (selectionMode === 'OR') {
			const isSelectedType = x => selectedTypes.includes(x); // FIXME [1]
			passed = _.someIn(types, isSelectedType);
		} else {
			// orgs that are JUST a company or that are BOTH a company & a funder
			// NOTE relies on both array being previously sorted

			passed = isEqual(types, selectedTypes);
		}

		return passed;
	}

const makeIsTextInOrg = regexp =>
	({name, description}) =>
		isNotNil(name?.match(regexp) || description?.match(regexp));

const makeIsOrgInPlace = regexp =>
	({place: {name} }) => isNotNil(name?.match(regexp));

export const _orgs = derived(
	[
		_bboxOrgs,
		_orgSearchRegex,
		_placesSearchRegex,
		_orgTypesSelectionMode,
		_selectedOrgTypes,
	],
	([
		bboxOrgs,
		orgSearchRegex,
		placesSearchRegex,
		orgTypesSelectionMode,
		selectedOrgTypes,
	]) => {
		const predicates = [
			makeIsOrgOfTypes(selectedOrgTypes, orgTypesSelectionMode)
		];

		if (isRegexpNotEmpty(orgSearchRegex)) {
			predicates.push(makeIsTextInOrg(orgSearchRegex))
		}
		if (isRegexpNotEmpty(placesSearchRegex)) {
			predicates.push(makeIsOrgInPlace(placesSearchRegex))
		}

		return _.filter(bboxOrgs, _.allOf(predicates));
	});

/* org count */

export const _orgsCount = derived(_orgs, getLength);

/* org types */

export const _keyOrgTypeValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {orgTypes}]) => {
		const orgTypesCount = countOrgTypes({orgs, orgTypes});
		const keyValueArray = objectToKeyValueArray(orgTypesCount);

		return keyValueArray;
	}
);

/* barchart by topic */

export const _keyTopicIdValueOrgsCount = derived(
	_orgs,
	_.pipe([
		_.flatMapWith(getTopics),
		_.countBy(getId),
		objectToKeyValueArray,
		_.sortWith([
			_.sorterDesc(getValue),
			getKey
		]),
		_.take(100)
	])
);

/* barchart by place */

const makeKeyPlaceIdValueOrgsCount = _.pipe([
	_.countBy(_.getKey('place_id')),
	objectToKeyValueArray,
]);
export const _keyPlaceLabelValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {placesById}]) => sortValueDescKeyAsc(
		_.map(
			makeKeyPlaceIdValueOrgsCount(orgs),
			({key, value}) => ({
				key: `${placesById[key].name} (${placesById[key].type})`,
				value
			})
		)
	)
);

/* barchart by region */

const makeKeyRegionIdValueOrgsCount = _.pipe([
	_.countBy(_.getPath('place.region_id')),
	objectToKeyValueArray,
]);
export const _keyRegionLabelValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {regionsById}]) => sortValueDescKeyAsc(
		_.map(
			makeKeyRegionIdValueOrgsCount(orgs),
			({key, value}) => ({
				key: `${regionsById[key].name} (${key})`,
				value
			})
		)
	)
);
