import {
	getId,
	getKey,
	getValue,
	objectToKeyValueArray,
	sortValueDescKeyAsc,
} from '@svizzle/utils';
import isEqual from 'just-compare';
import * as _ from 'lamb';
import {derived} from 'svelte/store';

import {_dataset} from 'app/stores/dataset';
import {
	_bbox_WSEN,
	_orgSearchText,
	_orgTypesSelectionMode,
	_selectedOrgTypes,
} from 'app/stores/selection';
import {countOrgTypes, getTopics} from 'app/utils/dataUtils';

/* filtered orgs */

const makeIsOrgWithinBbox = ([w, s, e, n]) =>
	({location: {lat, lon}}) =>
		lon >= w &&
		lat >= s &&
		lon <= e &&
		lat <= n;

/* [1] FIXME using:

```
const isSelectedType = makeIsIncluded(selectedTypes);
```

fails to select `University of Oxford` (which is a funder & a university),
if we select 'University / RTO' only

NOTE that this would work:

```
isSelectedType = _.pipe([tapValue(), makeIsIncluded(selectedTypes)])
```
*/
const makeIsOrgOfTypes = (selectedTypes, selectionMode) =>
	({types}) => {
		let passed;

		if (selectionMode === 'OR') {
			const isSelectedType = x => selectedTypes.includes(x); // FIXME [1]
			passed = _.someIn(types, isSelectedType);
		} else {
			// orgs that are JUST a company or that are BOTH a company & a funder
			// NOTE relies on both array being previously sorted

			passed = isEqual(types, selectedTypes);
		}

		return passed;
	}

const makeIsTextInOrg =
	text => {
		console.log('making', text)
		return ({label, description}) =>
			label?.toLowerCase().includes(text) ||
			description?.toLowerCase().includes(text);
	}


export const _bboxOrgs = derived(
	[_bbox_WSEN, _dataset],
	([bbox_WSEN, {orgs}]) => _.filter(orgs, makeIsOrgWithinBbox(bbox_WSEN))
);

export const _orgs = derived(
	[_bboxOrgs, _orgTypesSelectionMode, _selectedOrgTypes, _orgSearchText],
	([bboxOrgs, selectionMode, selectedOrgTypes, orgSearchText]) => _.pipe([
		_.filterWith(
			makeIsOrgOfTypes(selectedOrgTypes, selectionMode)
		),
		_.filterWith(makeIsTextInOrg(orgSearchText.toLowerCase()))
	])(bboxOrgs)
);

/* org types */

export const _keyOrgTypeValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {orgTypes}]) => {
		const orgTypesCount = countOrgTypes({orgs, orgTypes});
		const keyValueArray = objectToKeyValueArray(orgTypesCount);

		return keyValueArray;
	}
);

/* barchart by topic */

export const _keyTopicIdValueOrgsCount = derived(
	_orgs,
	_.pipe([
		_.flatMapWith(getTopics),
		_.countBy(getId),
		objectToKeyValueArray,
		_.sortWith([
			_.sorterDesc(getValue),
			getKey
		]),
		_.take(100)
	])
);

/* barchart by place */

const makeKeyPlaceIdValueOrgsCount = _.pipe([
	_.countBy(_.getKey('place_id')),
	objectToKeyValueArray,
]);
export const _keyPlaceLabelValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {placesById}]) => sortValueDescKeyAsc(
		_.map(
			makeKeyPlaceIdValueOrgsCount(orgs),
			({key, value}) => ({
				key: `${placesById[key].name} (${placesById[key].type})`,
				value
			})
		)
	)
);

/* barchart by region */

const makeKeyRegionIdValueOrgsCount = _.pipe([
	_.countBy(_.getPath('place.region_id')),
	objectToKeyValueArray,
]);
export const _keyRegionLabelValueOrgsCount = derived(
	[_orgs, _dataset],
	([orgs, {regionsById}]) => sortValueDescKeyAsc(
		_.map(
			makeKeyRegionIdValueOrgsCount(orgs),
			({key, value}) => ({
				key: `${regionsById[key].name} (${key})`,
				value
			})
		)
	)
);
