<script>
	import geoViewport from '@mapbox/geo-viewport';
	import mapboxgl from 'mapbox-gl';
	import {beforeUpdate, onMount, createEventDispatcher} from 'svelte';

	import {clearHero} from '$lib/stores/interaction';
	import {_bbox_WS_EN, _bbox_WSEN, _zoom} from '$lib/stores/selection';

	import {
		FIT_PADDING,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_TILE_SIZE
	} from './consts';
	import {CustomControl} from './util';

	const dispatch = createEventDispatcher();

	export let accessToken = null;
	export let bounds;
	export let customControl;
	export let CustomLayers = null;
	export let getLonLat;
	export let items = [];
	export let styleURL;
	export let withScaleControl = true;
	export let withZoomControl = true;

	/* props */

	let doesMapExist;
	let height = 0;
	let isInteractive = true; // has to be true initially
	let map;
	let mapcontainer;
	let projectFn;
	let width = 0;

	/* bbox */

	$: viewport = geoViewport.viewport(
		$_bbox_WSEN,
		[width, height],
		MAPBOXGL_MIN_ZOOM,
		MAPBOXGL_MAX_ZOOM,
		MAPBOXGL_TILE_SIZE
	);

	/* layers */

	let customLayers;

	$: projectFn && customLayers && customLayers.$set({projectFn});
	$: getLonLat && height && items && width && customLayers &&
		customLayers.$set({
			getLonLat,
			height,
			items,
			width,
		});

	/* controls */

	const addAttributionControl = () => {
		map.addControl(
			new mapboxgl.AttributionControl({
				compact: true
			})
		)
	};

	const addScaleControl = () => {
		map.addControl(
			new mapboxgl.ScaleControl({
				maxWidth: 80,
				unit: 'metric'
			}),
			'top-right'
		);
	};

	const addZoomControl = () => {
		map?.addControl(
			new mapboxgl.NavigationControl({
				showCompass: false
			}),
			'bottom-right'
		);
	};

	const addControls = () => {
		addAttributionControl();

		if (withScaleControl) {
			addScaleControl();
		}

		if (withZoomControl) {
			addZoomControl();
		}

		if (customControl) {
			const control = new CustomControl(customControl.control);
			map?.addControl(control, customControl.position);
		}
	};

	/* bbox */

	const fitToBbox = bbox_WSEN => {
		map?.fitBounds(bbox_WSEN, {
			linear: true,
			padding: {
				bottom: FIT_PADDING,
				left: FIT_PADDING,
				right: FIT_PADDING,
				top: FIT_PADDING,
			}
		});
	};

	/* custom layers */

	const addCustomLayers = () => {
		if (CustomLayers) {
			const canvasContainer = map.getCanvasContainer();

			customLayers = new CustomLayers({
				target: canvasContainer,
				props: {
					getLonLat,
					height,
					items,
					map,
					projectFn: x => map.project(x),
					width,
				}
			});
		}
	};

	/* events */

	const updateBbox = () => {
		if (map) {
			const mapBounds = map.getBounds().toArray();
			$_bbox_WS_EN = mapBounds;
		}
	}

	const updateProjection = () => {
		if (map) {
			projectFn = x => map.project(x);
		}
	};
	const updateZoom = () => {
		if (map) {
			const zoom = map.getZoom();
			_zoom.set(zoom);
		}
	}

	const setMapEvents = () => {
		map.on('move', event => {
			updateProjection();
			updateBbox();
			const {originalEvent} = event;
			if (originalEvent && originalEvent.type !== 'resize') {
				dispatch('bboxChanged');
			}
		});
		map.on('zoom', () => {
			updateZoom();
		});
		map.on('boxzoomend', () => {
			dispatch('bboxChanged');
		});
	}

	/* methods */

	// FIXME TBD: bind instead?
	const setGeometry = () => {
		if (!mapcontainer) {
			return;
		}

		const elementGeometry = getComputedStyle(mapcontainer);
		width = parseFloat(elementGeometry.width);
		height = parseFloat(elementGeometry.height);
	};

	const createMap = () => {
		const {center, zoom} = viewport;

		mapboxgl.accessToken = accessToken;

		map = new mapboxgl.Map({
			center,
			container: mapcontainer,
			maxZoom: MAPBOXGL_MAX_ZOOM,
			minZoom: MAPBOXGL_MIN_ZOOM,
			renderWorldCopies: false,
			style: styleURL,
			zoom,

			// interactions
			attributionControl: false, // we add this later to have it compact
			doubleClickZoom: isInteractive,
			dragPan: isInteractive,
			dragRotate: false,
			pitchWithRotate: false, // don't render dots in perspective
			scrollZoom: isInteractive,
			touchPitch: false,
			touchZoomRotate: isInteractive,
		})
		.on('load', () => {
			addCustomLayers();
			setMapEvents();
			bounds && fitToBbox(bounds);
			updateZoom();

			setGeometry(); // ipad FIXME: initial svg is 100x100
		})
		.on('click', () => {
			clearHero();
		});

		map.touchZoomRotate.disableRotation();

		// controls

		addControls();
	};

	/* lifecycle */

	beforeUpdate(() => {
		if (viewport && height > 0 && !doesMapExist) {
			doesMapExist = true;
			createMap();
		}
	})

	onMount(() => {
		setGeometry();
	});

	const onResize = () => {
		setGeometry();
		bounds && fitToBbox(bounds);
	}

	$: bounds && fitToBbox(bounds);
	$: map?.setStyle(styleURL);
</script>

<svelte:head>
	<link
		href='/css/mapbox-gl.css'
		rel='stylesheet'
		type='text/css'
	>
</svelte:head>

<svelte:window on:resize={onResize} />

<div class='MapboxglBase'>
	<div
		bind:this={mapcontainer}
		class='mapcontainer'
	></div>
</div>

<style>
	.MapboxglBase {
		height: 100%;
		position: relative;
		width: 100%;
	}

	.mapcontainer {
		height: 100%;
		width: 100%;
	}

	:global(.mapboxgl-canvas:focus-visible),
	:global(.mapboxgl-ctrl-group button:focus:focus-visible),
	:global(.mapboxgl-ctrl-logo:focus:focus-visible),
	:global(.mapboxgl-ctrl-attrib-button:focus) {
		box-shadow: none !important;
		/* box-shadow: var(--focusShadow) !important; */
		outline: var(--outline);
		outline-offset: calc(var(--focusLineWidth) * -1);
	}
</style>
